package edu.mit.csail.jasongao.vnconsistent;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OptionalDataException;

import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class CSMLayer {
	final static private String TAG = "CSMLayer";

	// Attributes
	private boolean cacheEnabled;
	boolean synced;
	private CSMState csmState;

	public VNCDaemon vncDaemon;

	/** This function only receives packets destined for our region */
	public synchronized void handlePacket(Packet vnp) {
		// Log.d(TAG, "heard csm packet: " + vnp.toString());
		if (!vnp.dstRegion.equals(csmState.region))
			return;

		Packet reply;
		switch (vnp.subtype) {
		case Packet.READ_REQ: // someone wants to read from our HOME space
			logMsg(String.format("recv READ_REQ from %d,%d, responding READ_REP",
					vnp.srcRegion.x, vnp.srcRegion.y));
			reply = new Packet(-1, -1, Packet.CSM_MSG,
					Packet.READ_REPLY, csmState.region, vnp.srcRegion);
			reply.csm_home = vnp.csm_home;
			reply.csm_tag = vnp.csm_tag;
			reply.csm_line = csmState.get(csmState.region, vnp.csm_tag);
			sendPacket(reply);
			break;
		case Packet.READ_REPLY: // we received a reply to our READ request
			csmState.put(vnp.csm_home, vnp.csm_tag, vnp.csm_line); // cache it
			vncDaemon.app.readFinished(vnp.csm_home.x, vnp.csm_home.y,
					vnp.csm_tag, vnp.csm_line);
			break;
		case Packet.WRITE_REQ: // someone wants to write to our HOME space
			logMsg(String.format("recv WRITE_REQ from %d,%d, responding WRITE_UPDATEs",
					vnp.srcRegion.x, vnp.srcRegion.y));
			// do the write
			csmState.put(csmState.region, vnp.csm_tag, vnp.csm_line);
			// TODO lock the line until all caches are updated
			reply = new Packet(-1, -1, Packet.CSM_MSG,
					Packet.WRITE_UPDATE, csmState.region, vnp.srcRegion);
			reply.csm_home = csmState.region;
			reply.csm_tag = vnp.csm_tag;
			reply.csm_line = vnp.csm_line;
			sendPacket(reply);
			if (this.cacheEnabled) {
				// send WRITE_UPDATE to every remote cache
			}
			vncDaemon.app.writeFinished(vnp.csm_home.x, vnp.csm_home.y,
					vnp.csm_tag, vnp.csm_line); // TODO debug?
			break;
		case Packet.WRITE_UPDATE: // we received a reply to our WRITE request
										// or we should update our cached READ
			logMsg(String
					.format("recv WRITE_UPDATE from %d,%d, responding WRITE_UPDATE_ACK",
							vnp.srcRegion.x, vnp.srcRegion.y));
			this.csmState.put(vnp.csm_home, vnp.csm_tag, vnp.csm_line);
			// if it's for our HOME / region, pass it to the callback fn in App
			vncDaemon.app.writeFinished(vnp.csm_home.x, vnp.csm_home.y,
					vnp.csm_tag, vnp.csm_line);
			reply = new Packet(-1, -1, Packet.CSM_MSG,
					Packet.WRITE_UPDATE_ACK, csmState.region, vnp.srcRegion);
			reply.csm_home = vnp.csm_home;
			reply.csm_tag = vnp.csm_tag;
			sendPacket(reply);
			break;
		case Packet.WRITE_UPDATE_ACK: // remote cache acknowledges our update
			logMsg(String.format("recv WRITE_UPDATE_ACK from %d,%d",
					vnp.srcRegion.x, vnp.srcRegion.y));
			// TODO unlock the line once all caches are updated
			break;
		}
	}

	/** CSMLayer constructor */
	public CSMLayer(VNCDaemon vnc, boolean cacheEn, RegionKey r) {
		this.vncDaemon = vnc;
		this.cacheEnabled = cacheEn;
		this.csmState = new CSMState(r);
		this.synced = false;
	}

	public synchronized void init(RegionKey r) {
		this.csmState = new CSMState(r);
	}

	/** CSM API Read Request */
	public synchronized void read(long rx, long ry, String key) {
		RegionKey r = new RegionKey(rx, ry);
		if (r.equals(csmState.region)) { // if local request
			logMsg(String.format("csm local read of " + r + ":" + key));
			// return csmState.get(r, key);
			vncDaemon.app.readFinished(rx, ry, key, csmState.get(r, key));
			return;
		} else {
			if (cacheEnabled && csmState.containsKey(r, key)) {
				logMsg(String.format("csm cached remote read of " + r + ":"
						+ key));
				// return csmState.get(r, key);
				vncDaemon.app.readFinished(rx, ry, key, csmState.get(r, key));
				return;
			} else { // cache miss, make remote request
				logMsg(String.format("csm actual remote read of " + r + ":"
						+ key));
				Packet request = new Packet(-1, -1, Packet.CSM_MSG,
						Packet.READ_REQ, csmState.region, r);
				request.csm_home = r;
				request.csm_tag = key;
				sendPacket(request);
				// return null; // better way to indicate pending request?
				return;
			}
		}
	}

	/** CSM API Write Request */
	public synchronized void write(long rx, long ry, String key, byte[] value) {
		RegionKey r = new RegionKey(rx, ry);
		if (r.equals(csmState.region)) { // if local request
			logMsg(String.format("csm local write of " + r + ":" + key));
			csmState.put(r, new String(key), value);
			vncDaemon.app.writeFinished(rx, ry, key, csmState.get(r, key));
		} else {
			logMsg(String.format("csm remote write of " + r + ":" + key));
			if (cacheEnabled && csmState.containsKey(r, key)) {
				logMsg("remote line is in cache, invalidating");
				csmState.remove(r, key);
			}
			Packet request = new Packet(-1, -1, Packet.CSM_MSG,
					Packet.WRITE_REQ, csmState.region, r);
			request.csm_home = r;
			request.csm_tag = key;
			request.csm_line = value;
			sendPacket(request);
			return; // better way to indicate pending request?
		}
	}

	/** VNC-CSM interface - serialize CSM data to JSON */
	public synchronized String getJson() {
		// Gson gson = new Gson();
		Gson gson = new GsonBuilder().enableComplexMapKeySerialization()
				.create();
		String json = gson.toJson(csmState, CSMState.class);
		Log.d(TAG, "serialized to: " + json);
		return json;
	}

	/** VNC-CSM interface - deserialize CSM data from JSON */
	public synchronized void loadJson(String json) {
		// Gson gson = new Gson();
		Gson gson = new GsonBuilder().enableComplexMapKeySerialization()
				.create();
		csmState = gson.fromJson(json, CSMState.class);
		Log.d(TAG, "deserialized from: " + json);
		return;
	}

	/**
	 * VNC-CSM interface - serialize to byte array
	 * 
	 * @throws IOException
	 * @throws ClassNotFoundException
	 * @throws OptionalDataException
	 */
	public synchronized void loadBytes(byte[] d) throws OptionalDataException,
			ClassNotFoundException, IOException {
		ByteArrayInputStream bis = new ByteArrayInputStream(d);
		ObjectInputStream ois = new ObjectInputStream(bis);
		csmState = (CSMState) ois.readObject();
		ois.close();
	}

	/**
	 * VNC-CSM interface - deserialize from byte array
	 * 
	 * @throws IOException
	 */
	public synchronized byte[] getBytes() throws IOException {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutput out = new ObjectOutputStream(bos);
		out.writeObject(csmState);
		out.close();
		return bos.toByteArray();
	}

	/** VNC-CSM interface - get hash */
	public synchronized byte[] getHash() {
		// TODO SHA-1 JNI?
		return null;
	}

	/** Log message to device display and to Android log. */
	private void logMsg(String msg) {
		vncDaemon.logMsg(msg);
	}

	/** Send a packet through the network thread */
	public void sendPacket(Packet p) {
		vncDaemon.muxHandler.obtainMessage(Mux.PACKET_SEND, p).sendToTarget();
	}
}