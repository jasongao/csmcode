package edu.mit.csail.jasongao.vnconsistent;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;

public class Mux extends Thread {
	private final static String TAG = "Mux";

	Handler myHandler;
	Handler activityHandler;

	// Mux message types
	protected final static int LOG = 3;
	protected final static int PACKET_RECV = 4;
	protected final static int PACKET_SEND = 5;
	protected final static int STATUS_CHANGE = 6;
	protected final static int REGION_CHANGE = 7;
	protected static final int PARKING_CHANGE = 8;

	// Components TODO make private
	private NetworkThread netThread;
	public VNCDaemon vncDaemon;
	
	public Queue<Packet> sendQueue;
	public Queue<Packet> recvQueue; 

	/** Mux constructor */
	public Mux(Handler a) {
		activityHandler = a;
	}

	/** Take action on message sent to my handler. */
	private void processMessage(Message msg) {
		switch (msg.what) {
		case Mux.PACKET_RECV:
			Packet vnp = (Packet) msg.obj;
			// forward towards destination region, once at most, x-y routing
			// only do for CSM layer messages?
			if (false && vnp.type == Packet.CSM_MSG
					&& !vnp.dstRegion.equals(vncDaemon.myRegion)) {
				if (vnp.dstRegion.x == vncDaemon.myRegion.x
						&& vnp.srcRegion.y < vncDaemon.myRegion.y
						&& vncDaemon.myRegion.y < vnp.dstRegion.y) {
					netThread.sendPacket((Packet) msg.obj);
				} else if (vnp.srcRegion.x < vncDaemon.myRegion.x
						&& vncDaemon.myRegion.x < vnp.dstRegion.x) {
					netThread.sendPacket((Packet) msg.obj);
				}
				// store nonce so we don't forward this packet endlessly
				// TODO
			}
			vncDaemon.myHandler.sendMessage(Message.obtain(msg));
			break;
		case Mux.PACKET_SEND:
			sendQueue.add((Packet) msg.obj);
			break;
		case Mux.LOG:
			activityHandler.sendMessage(Message.obtain(msg));
			break;
		case Mux.STATUS_CHANGE:
			activityHandler.sendMessage(Message.obtain(msg));
			break;
		case Mux.REGION_CHANGE:
			activityHandler.sendMessage(Message.obtain(msg));
			break;
		case Mux.PARKING_CHANGE:
			activityHandler.sendMessage(Message.obtain(msg));
			break;
		}
	}

	/** Stuff to do right before we enter the run loop. */
	private void onStart() {
		Log.d(TAG, "Mux started");

		// Start the network thread and ensure it's running
		netThread = new NetworkThread(myHandler);
		if (!netThread.socketIsOK()) {
			Log.e(TAG, "Cannot start server: socket not ok.");
			return; // quit out
		}
		netThread.start();
		if (netThread.getLocalAddress() == null) {
			Log.e(TAG, "Couldn't get my IP address.");
			return; // quit out
		}

		long id = netThread.getLocalAddress().getAddress()[3]; // id = last oct
		
		this.sendQueue = new ConcurrentLinkedQueue<Packet>();
		
		vncDaemon = new VNCDaemon(myHandler, id, 700, 700, 8, 8);
		vncDaemon.start();
	}

	/** Stuff to do right BEFORE exiting the run loop. */
	private void onStop() {
		vncDaemon.requestStop();
		netThread.closeSocket();
	}

	/**
	 * Don't modify stuff below this line
	 */

	/** Thread's run method */
	@Override
	public void run() {
		// Prepare looper and handler on current thread
		Looper.prepare();
		myHandler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				processMessage(msg);
			}
		};
		onStart(); // Start up
		Looper.loop();
		Log.i(TAG, "Loop ended, onStop() finished, thread exiting");
	}

	/** Exit after all queued tasks are done. */
	public synchronized void requestStop() {
		myHandler.post(new Runnable() {
			@Override
			public void run() {
				Log.i(TAG, "Stop request encountered.");
				onStop();
				Looper.myLooper().quit();
			}
		});
	}
}
